using IMPL.SourceGen.MemberCodes;
using IMPL.SourceGen.Modifiers;
using IMPL.SourceGen.Writers;

using System.Diagnostics;

namespace IMPL.SourceGen;

public class Implementer
{
    public ImplSpec ImplSpec { get; }

    public IFieldSigWriter FieldWriter { get; internal set; }
    public IPropertySigWriter PropertyWriter { get; internal set; }
    public IEventSigWriter EventWriter { get; internal set; }

    public List<(MemberPos, object)> Members { get; }

    public List<IImplModifier> ImplModifiers { get; }

    public Implementer(ImplSpec spec)
    {
        ImplSpec = spec;
        // Use default fieldwriter
        FieldWriter = DefaultFieldSigWriter.Instance;
        // Assume simple property writer unless we override
        PropertyWriter = SimplePropertySigWriter.Instance;
        // Same for events
        EventWriter = SimpleEventSigWriter.Instance;
        // Setup ctor + methodwriters
        Members = new();
        AddMember(new PropertyConstructorsCode());

        ImplModifiers = new()
        {
            new BackingFieldModifier(),
            new DisposableModifier(),
        };


        // Add all known members
        foreach (var member in spec.Members)
        {
            AddMember(member);
        }

        // Pre-register non-interface specific
        ImplModifiers.Where(im => im is not IInterfaceImplementationModifier).Consume(im => im.PreRegister(this));

        // Scan interfaces for writer overrides
        foreach (var interfaceType in spec.InterfaceTypes)
        {
            var handler = ImplModifiers.FirstOrDefault(io => io is IInterfaceImplementationModifier iim && iim.AppliesTo(interfaceType));
            if (handler is not null)
            {
                handler.PreRegister(this);
            }
        }
    }


    public void AddMember(IMemberCode memberCode)
    {
        Members.Add((memberCode.Pos, memberCode));
    }

    public void AddMember(MemberSig memberSig)
    {
        MemberPos memberPos = new()
        {
            Instic = memberSig.Instic,
            Visibility = memberSig.Visibility,
            SigType = memberSig.SigType,
        };
        Members.Add((memberPos, memberSig));
    }

    public IEnumerable<TMember> GetMembers<TMember>()
        where TMember : MemberSig
    {
        return Members
            .Select(static p => p.Item2)
            .OfType<TMember>();
    }



    private void WriteInterfaces(CodeBuilder codeBuilder)
    {
        var spec = ImplSpec;
        var interfaceTypes = spec.InterfaceTypes;

        if (interfaceTypes.Count == 0) return;
        codeBuilder.AppendLine(" : ")
            .IndentBlock(ib => ib.DelimitAppend(static b => b.Append(',').NewLine(), interfaceTypes));
    }


    public SourceCode Implement()
    {
        // Here we go
        var spec = ImplSpec;
        var implType = spec.ImplType;


        using var codeBuilder = new CodeBuilder();
        codeBuilder
            .AutoGeneratedHeader()
            .Nullable(true)
            // usings
            .Namespace(implType.Namespace)
            .NewLine()
            // type decleration
            .Append(implType.Visibility, "lc")
            .AppendIf(implType.Instic == Instic.Static, " static ", " ")
            .AppendKeywords(implType.Keywords)
            .Append(implType.ObjType, "lc").Append(' ')
            .Append(implType.Name)
            .If(spec.InterfaceTypes.Count > 0, WriteInterfaces)
            .BracketBlock(typeBlock =>
            {
                // Static, Instance
                foreach (Instic instic in new[] { Instic.Static, Instic.Instance })
                {
                    // operators, fields, properties, events, constructors, methods
                    foreach (SigType sigType in new[] { SigType.Operator, SigType.Field, SigType.Property, SigType.Event, SigType.Constructor, SigType.Method })
                    {
                        // private -> public
                        foreach (Visibility visibility in new[] { Visibility.Private, Visibility.Protected, Visibility.Protected | Visibility.Internal, Visibility.Internal, Visibility.Public })
                        {
                            // What do we have in this section?
                            var sectionMembers = Members.Where(p =>
                            {
                                var pos = p.Item1;
                                return pos.Instic == instic && pos.SigType == sigType && pos.Visibility == visibility;
                            }).ToList();

                            if (sectionMembers.Count == 0) continue;

                            foreach ((MemberPos pos, object? obj) in sectionMembers)
                            {
                                if (obj is IMemberCode memberCode)
                                {
                                    memberCode.Write(this, codeBuilder);
                                }
                                else if (obj is FieldSig fieldSig)
                                {
                                    FieldWriter.Write(fieldSig, codeBuilder);
                                }
                                else if (obj is PropertySig propertySig)
                                {
                                    PropertyWriter.Write(propertySig, codeBuilder);
                                }
                                else if (obj is EventSig eventSig)
                                {
                                    EventWriter.Write(eventSig, codeBuilder);
                                }
                                else if (obj is MethodSig methodSig)
                                {
                                    // Ignore Getters + Setters, they'll have been handled by their property
                                    if (methodSig.Name!.StartsWith("get_") ||
                                        methodSig.Name!.StartsWith("set_"))
                                    {
                                        // Ignore
                                        continue;
                                    }

                                    // Maybe handled by an interface Implementer?

                                    //throw new NotImplementedException();
                                }
                                else
                                    Debugger.Break();
                            }

                            // Newline before next section!
                            typeBlock.NewLine();
                        }
                    }
                }


                // Cleanup excess whitespace
                typeBlock.TrimEnd();
            });

        string fileName = $"{implType.FullName}.g.cs";
        string code = codeBuilder.ToString();
        return new SourceCode(fileName, code);
    }
}
